const MIN = 1;
const MAX = 5;
const commentLength = 40;
const clearArray = [];

const getClearArray = (minIn, maxIn) => {
  for (let i = minIn; i <= maxIn; ++i) {
    clearArray[i - 1] = i;
  }

  return clearArray;
};
// console.log(getClearArray(MIN, MAX));


/*
Алгоритм беспристрастного перемешивания — перетасовка Фишера-Йейтса (он же Кнут)
[http://en.wikipedia.org/wiki/Fisher-Yates_shuffle]
Вы можете увидеть отличную визуализацию здесь
[http://bost.ocks.org/mike/shuffle/]
(и исходный пост , связанный с этим)
[http://sedition.com/perl/javascript-fy.html]
*/
function shuffle(array) {
  let currentIndex = array.length;
  let randomIndex;

  console.log('currentIndex до: ', currentIndex);
  // Пока остаются элементы для перетасовки.
  while (currentIndex !== 0) {

    // Выберите оставшийся элемент
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex--;
    console.log('randomIndex: ', randomIndex);
    console.log('currentIndex после: ', currentIndex);

    // И замените его текущим элементом.
    console.log(array);
    console.log([array[currentIndex], array[randomIndex]]);
    console.log([array[randomIndex], array[currentIndex]]);
    [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
    console.log(array);
  }

  return array;
}

console.log(shuffle(getClearArray(MIN, MAX)));


// /**
//  * @param {number} minIn
//  * @param {number} maxIn
//  */
// const getRandomInt = (minIn, maxIn) => {
//   if (!Number.isInteger(minIn) || minIn < 0 || !Number.isInteger(maxIn) || maxIn < 0 || maxIn < minIn) {
//     return NaN;
//   }

//   return Math.round((maxIn - minIn) * Math.random() + minIn);
// };

// console.log(getRandomInt(MIN, MAX));


// // http://stackoverflow.com/questions/962802#962890
// const a = [];
// for (let i = 0; i < 25; ++i) { a[i] = i; }

// function shuffle(array) {
//   let tmp,
//     current,
//     top = array.length;

//   if (top) {
//     while (--top) {
//       current = Math.floor(Math.random() * (top + 1));
//       tmp = array[current];
//       array[current] = array[top];
//       array[top] = tmp;
//     }
//     return array;
//   }
// }

// console.log(shuffle(a));


// //  реализация перетасовки Фишера-Йейтса @Christoph
// function shuffle1(array) {
//   for (let tmp, cur, top = array.length; top--;){
//     cur = (Math.random() * (top + 1)) << 0;
//     tmp = array[cur];
//     array[cur] = array[top];
//     array[top] = tmp;
//   }
//   return array;
// }
// console.log(shuffle1(a));


// // https://stackoverflow.com/questions/5836833/create-an-array-with-random-values
// // https://stackoverflow.com/questions/962802/is-it-correct-to-use-javascript-array-sort-method-for-shuffling#962890
// // https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
// // https://stackoverflow.com/questions/962802/is-it-correct-to-use-javascript-array-sort-method-for-shuffling/962829#962829


/**
 * @param {string} value
 * @param {number} valueParam
 */
const checkLengthString = (value, valueParam) => {
  if (value.length > valueParam) {
    throw new Error(`Комментарий превышает ${valueParam} символов!!!`);
  }

  return value;
};

// checkLengthString('Проверка длины комментария', commentLength);
console.log(checkLengthString('Длина комментария проверена', commentLength));




Вот реализация JavaScript перетасовки Durstenfeld , оптимизированной версии Fisher-Yates:
http://en.wikipedia.org/wiki/Fisher-Yates_shuffle#The_modern_algorithm
/* Randomize array in-place using Durstenfeld shuffle algorithm */
function shuffleArray(array) {
    for (var i = array.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}
Он выбирает случайный элемент для каждого исходного элемента массива и исключает его из следующего розыгрыша, как случайный выбор из колоды карт.

Это умное исключение меняет выбранный элемент на текущий, затем выбирает следующий случайный элемент из остатка, возвращаясь назад для оптимальной эффективности, обеспечивая упрощение случайного выбора (он всегда может начинаться с 0) и, таким образом, пропускает последний элемент.

Время выполнения алгоритма O(n). Обратите внимание , что перемешивание выполняется на месте, поэтому, если вы не хотите изменять исходный массив, сначала сделайте его копию с помощью .slice(0).

https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array/2450976#2450976














const MIN = 1;
const MAX = 25;
const clearArray = [];
const commentLength = 40;

const getClearArray = (minIn, maxIn) => {
  for (let i = minIn; i <= maxIn; ++i) {
    clearArray[i - 1] = i;
  }

  return clearArray;
};


const shuffle = (array) => {
  // let currentIndex = array.length;
  // let randomIndex;

  // while (currentIndex !== 0) {
  //   randomIndex = Math.floor(Math.random() * currentIndex);
  //   currentIndex--;
  //   [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
  // }

  let currentIndex = array.length - 1;
  let randomIndex;

  for (currentIndex; currentIndex > 0; currentIndex--) {
    randomIndex = Math.floor(Math.random() * (currentIndex + 1));
    [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
  }

  return array;
};

console.log(shuffle(getClearArray(MIN, MAX)));

https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array/2450976#2450976
